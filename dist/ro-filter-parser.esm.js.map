{"version":3,"file":"ro-filter-parser.esm.js","sources":["../src/util/category.js","../src/util/object-to-string.js","../src/util/get-object-index.js","../src/util/siv.js","../src/util/clean-object.js","../src/util/extract-siv-included.js","../src/ro-filter-parser.js"],"sourcesContent":["/* eslint-disable no-param-reassign */\nconst categoryTypes = [\n  'includedWithSubcategories',\n  'includedWithoutSubcategories',\n  'excludedWithSubcategories',\n  'excludedWithoutSubcategories',\n];\n\nexport function setCategoryCodes(subtype, values) {\n  const updatedCat = {};\n  if (subtype === 'subcategory-included') {\n    updatedCat.includedWithSubcategories = [...values];\n  }\n  if (subtype === 'subcategory-excluded') {\n    updatedCat.includedWithoutSubcategories = [...values];\n  }\n  return updatedCat;\n}\n\nexport function addCategoryCodes(categoryObject, subtype, values) {\n  // If the value already exists anywhere in categories, remove it\n  categoryTypes.forEach(type => {\n    if (categoryObject[type]) {\n      categoryObject[type] = categoryObject[type].filter(value => !values.includes(value));\n    }\n  });\n  if (subtype === 'subcategory-included') {\n    const currentValues = categoryObject.includedWithSubcategories || [];\n    categoryObject.includedWithSubcategories = Array.from(new Set([...currentValues, ...values]));\n  }\n  if (subtype === 'subcategory-excluded') {\n    const currentValues = categoryObject.includedWithoutSubcategories || [];\n    categoryObject.includedWithoutSubcategories = Array.from(new Set([...currentValues, ...values]));\n  }\n  return categoryObject;\n}\n","// Coz flatMap seems to be implemented only in Node11\nimport { flatten } from 'ramda';\n\nexport default function convertObjectToString(filter) {\n  if (filter.constructor === Array) {\n    return filter.map(f => `${convertObjectToString(f)}`).join('|');\n  }\n  if (filter.constructor === Object) {\n    const filterArray = [];\n    if (filter.SIV_ATTRIBUTE) {\n      const filterStringArray = flatten(\n        Object.keys(filter.SIV_ATTRIBUTE).map(type =>\n          Object.keys(filter.SIV_ATTRIBUTE[type]).map(subtype => {\n            const equalOp = subtype.includes('include') ? '==' : '!=';\n            const values = filter.SIV_ATTRIBUTE[type][subtype].map(value => `${value}`).join(',');\n            return `SIV_ATTRIBUTE(${type})${equalOp}[${values}]`;\n          })\n        )\n      );\n\n      filterArray.push(...filterStringArray);\n    }\n    if (filter.CATEGORY) {\n      const { CATEGORY } = filter;\n      const filterStringArray = Object.keys(CATEGORY).map(key => {\n        const equalOp = key.includes('include') ? '==' : '!=';\n        const subcategoryOp = key.includes('Without') ? 'false' : 'true';\n        const values = CATEGORY[key].map(value => `\"${value}\"`).join(',');\n        return `CATEGORY(${subcategoryOp})${equalOp}[${values}]`;\n      });\n      filterArray.push(filterStringArray);\n    }\n    if (filter.array) {\n      filterArray.push(convertObjectToString(filter.array));\n    }\n    return filterArray.length > 1 ? `(${filterArray.join('&')})` : filterArray.join('&');\n  }\n  return '';\n}\n","export default function getObjectIndex(filterArray) {\n  let result;\n  filterArray.forEach((f, i) => {\n    if (JSON.stringify(f) !== '{}') {\n      result = i;\n    }\n  });\n  return result;\n}\n","import { mergeDeepRight } from 'ramda';\nimport getObjectIndex from './get-object-index';\n\n/* eslint-disable no-param-reassign */\nexport default function setSivValues(parsedFilter, sivIncluded, subtype, values) {\n  let includedIds = sivIncluded ? sivIncluded.SIV_ATTRIBUTE.id.included : [];\n  if (subtype === 'id-included') {\n    includedIds = values;\n    // Rewrite this so that we don't need param reassign\n    parsedFilter.forEach((f, index) => {\n      if (\n        parsedFilter[index].SIV_ATTRIBUTE\n        && parsedFilter[index].SIV_ATTRIBUTE.id\n        && parsedFilter[index].SIV_ATTRIBUTE.id.excluded\n      ) {\n        parsedFilter[index].SIV_ATTRIBUTE.id.excluded = parsedFilter[index].SIV_ATTRIBUTE.id.excluded.filter(\n          id => !values.includes(id),\n        );\n      }\n      // If all the included values are filtered out, delete SIV_ATTRIBUTE key\n      if (\n        parsedFilter[index].SIV_ATTRIBUTE\n        && parsedFilter[index].SIV_ATTRIBUTE.id\n        && parsedFilter[index].SIV_ATTRIBUTE.id.excluded\n        && parsedFilter[index].SIV_ATTRIBUTE.id.excluded.length === 0\n      ) {\n        delete parsedFilter[index].SIV_ATTRIBUTE.id;\n      }\n    });\n  }\n  if (subtype === 'id-excluded') {\n    let updated = false;\n    if (sivIncluded) {\n      includedIds = includedIds.filter(id => !values.includes(id));\n    }\n    parsedFilter.forEach((f, index) => {\n      if (\n        parsedFilter[index].SIV_ATTRIBUTE\n        && parsedFilter[index].SIV_ATTRIBUTE.id\n        && parsedFilter[index].SIV_ATTRIBUTE.id.excluded\n      ) {\n        parsedFilter[index].SIV_ATTRIBUTE.id.excluded = values;\n        updated = true;\n      }\n    });\n    if (!updated) {\n      const index = getObjectIndex(parsedFilter);\n      parsedFilter[index] = mergeDeepRight(parsedFilter[index], { SIV_ATTRIBUTE: { id: { excluded: values } } });\n    }\n  }\n  if (subtype === 'supplier-included') {\n    const index = getObjectIndex(parsedFilter);\n    parsedFilter[index] = mergeDeepRight(parsedFilter[index], { SIV_ATTRIBUTE: { supplier: { included: values } } });\n  }\n  const updatedSivIncluded = includedIds.length ? { SIV_ATTRIBUTE: { id: { included: includedIds } } } : null;\n  return { parsedFilter, updatedSivIncluded };\n}\n","/**\n * This is used to remove any empty objects going through it recursively\n *\n * @export\n * @param {Object} obj\n * @returns {Object}\n *\n * @example\n  const test = {\n    SIV: {\n      id: {},\n      incl: [1]\n    },\n    SIV2: {\n      id: {\n        included: {}\n      }\n    }\n  }\n\n  cleanObject(test)\n  Output: { SIV: { incl: [ 1 ] } }\n */\nexport default function cleanObject(obj) {\n  const resultObject = {};\n  Object.keys(obj).forEach(key => {\n    if (obj[key].constructor === Object) {\n      resultObject[key] = cleanObject(obj[key]);\n      if (JSON.stringify(resultObject[key]) === '{}') {\n        delete resultObject[key];\n      }\n    } else {\n      resultObject[key] = obj[key];\n    }\n  });\n  return resultObject;\n}\n","export default function extractSivIncluded(parsedFilter, sivIncluded) {\n  let updatedSivIncluded = sivIncluded;\n  const updatedFilter = parsedFilter.map(filter => {\n    if (filter.SIV_ATTRIBUTE && filter.SIV_ATTRIBUTE.id.included) {\n      if (updatedSivIncluded) {\n        updatedSivIncluded.SIV_ATTRIBUTE.id.included.push(...filter.SIV_ATTRIBUTE.id.included);\n      } else {\n        updatedSivIncluded = {\n          SIV_ATTRIBUTE: {\n            id: {\n              included: filter.SIV_ATTRIBUTE.id.included,\n            },\n          },\n        };\n      }\n      delete filter.SIV_ATTRIBUTE.id.included;\n    }\n    if (filter.array) {\n      ({ updatedFilter: filter.array, updatedSivIncluded } = extractSivIncluded(filter.array, updatedSivIncluded));\n      // This is being done only because of the way the current filter definitions are set up where they are wrongly grouped based on the OR.\n      // Basically all the current definitions have been slightly wrong but because they were never grouped with anything else, it was not noticable.\n      filter.array.forEach(f => {\n        if (f.CATEGORY) {\n          filter.CATEGORY = f.CATEGORY;\n        }\n        delete f.CATEGORY;\n      });\n    }\n    return filter;\n  });\n  return { updatedFilter, updatedSivIncluded };\n}\n","import { setCategoryCodes, addCategoryCodes } from './util/category';\nimport convertObjectToString from './util/object-to-string';\nimport setSivValues from './util/siv';\nimport cleanObject from './util/clean-object';\nimport extractSivIncluded from './util/extract-siv-included';\n\nconst nearley = require('nearley');\nconst grammar = require('../src/compiled-grammar/main');\n\n/**\n * The main function of the library. Parses the filter string to return a JSON object\n *\n * @export\n * @param {string} filterString - the filter string\n * @returns {object} - a json representation of the string\n */\nexport function parseFilterString(filterString) {\n  // Create a Parser object from our grammar.\n  const parser = new nearley.Parser(nearley.Grammar.fromCompiled(grammar));\n  parser.feed(filterString);\n\n  const { results } = parser;\n  if (results.length > 1) return 'Ambigous grammar. Bad!';\n  if (results.length === 0) return 'Empty result. Weird!';\n\n  return results[0];\n}\n\nexport function addToFilter(definition, { label, subtype, values }) {\n  const parsedFilter = parseFilterString(definition);\n  switch (label) {\n    case 'CATEGORY':\n      parsedFilter.forEach((filter, index) => {\n        if (parsedFilter[index].CATEGORY) {\n          parsedFilter[index].CATEGORY = addCategoryCodes(filter.CATEGORY, subtype, values);\n        }\n      });\n      break;\n\n    default:\n      break;\n  }\n  return convertObjectToString(parsedFilter);\n}\n\nexport function setFilter(definition, { label, subtype, values }) {\n  let parsedFilter = parseFilterString(definition);\n\n  // SIV ATTRIBUTE Included is a special case where if the value is included that is \"ORed\" to all the other rules.\n  // So we extract it out\n  let sivIncluded;\n  ({ updatedSivIncluded: sivIncluded, updatedFilter: parsedFilter } = extractSivIncluded(parsedFilter, sivIncluded));\n\n  parsedFilter.forEach((filter, index) => {\n    if (parsedFilter[index].array) {\n      const cleanArray = parsedFilter[index].array.map(f => cleanObject(f)).filter(f => JSON.stringify(f) !== '{}');\n      if (cleanArray.length) {\n        parsedFilter[index].array = cleanArray;\n      } else {\n        delete parsedFilter[index].array;\n      }\n    }\n  });\n\n  switch (label) {\n    case 'CATEGORY': {\n      let updated = false;\n      parsedFilter.forEach((filter, index) => {\n        if (parsedFilter[index].CATEGORY) {\n          parsedFilter[index].CATEGORY = setCategoryCodes(subtype, values);\n          updated = true;\n        }\n      });\n      if (!updated) {\n        const CATEGORY = setCategoryCodes(subtype, values);\n        parsedFilter[0].CATEGORY = CATEGORY;\n      }\n      break;\n    }\n    case 'SIV': {\n      ({ updatedSivIncluded: sivIncluded, parsedFilter } = setSivValues(parsedFilter, sivIncluded, subtype, values));\n      break;\n    }\n\n    default:\n      break;\n  }\n\n  // Remove any empty objects (maybe caused by the SIV extraction)\n  parsedFilter.forEach((filter, index) => {\n    parsedFilter[index] = cleanObject(parsedFilter[index]);\n  });\n  parsedFilter = parsedFilter.filter(filter => JSON.stringify(filter) !== '{}');\n  if (sivIncluded && parsedFilter.length) {\n    parsedFilter.push(sivIncluded);\n  }\n  const convertedFilter = parsedFilter.length ? parsedFilter : sivIncluded;\n  return convertObjectToString(convertedFilter);\n}\n"],"names":[],"mappings":"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"}